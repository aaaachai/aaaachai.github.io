<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++智能指针 | 孤岛</title><meta name="author" content="柴"><meta name="copyright" content="柴"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++智能指针前言​	我们知道C&#x2F;C++可以使用指针直接对数据内存进行操作，这给了程序员极大的操作空间的同时，也需要C&#x2F;C++程序员注意更多的细节。在程序运行时，每个程序有一个内存池，这部分内存存储程序动态分配的对象。当所申请的动态对象不再使用时，我们应该显式的销毁他们以防止内存泄漏。（不同于栈区空间操作系统自行管理）。智能指针的出现，就是为了协助程序员更好的管理堆区空间，从而">
<meta property="og:type" content="article">
<meta property="og:title" content="C++智能指针">
<meta property="og:url" content="http://example.com/post/99c27b28.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="C++智能指针前言​	我们知道C&#x2F;C++可以使用指针直接对数据内存进行操作，这给了程序员极大的操作空间的同时，也需要C&#x2F;C++程序员注意更多的细节。在程序运行时，每个程序有一个内存池，这部分内存存储程序动态分配的对象。当所申请的动态对象不再使用时，我们应该显式的销毁他们以防止内存泄漏。（不同于栈区空间操作系统自行管理）。智能指针的出现，就是为了协助程序员更好的管理堆区空间，从而">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-29T08:01:21.000Z">
<meta property="article:modified_time" content="2023-03-30T11:54:08.859Z">
<meta property="article:author" content="柴">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/99c27b28"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++智能指针',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-30 19:54:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/chai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤岛</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++智能指针</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T08:01:21.000Z" title="发表于 2023-03-29 16:01:21">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T11:54:08.859Z" title="更新于 2023-03-30 19:54:08">2023-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++智能指针"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	我们知道C&#x2F;C++可以使用指针直接对数据内存进行操作，这给了程序员极大的操作空间的同时，也需要C&#x2F;C++程序员注意更多的细节。在程序运行时，每个程序有一个内存池，这部分内存存储程序动态分配的对象。当所申请的动态对象不再使用时，我们应该显式的销毁他们以防止内存泄漏。（不同于栈区空间操作系统自行管理）。智能指针的出现，就是为了协助程序员更好的管理堆区空间，从而避免内存泄漏！</p>
<h2 id="普通指针所造成的内存泄漏"><a href="#普通指针所造成的内存泄漏" class="headerlink" title="普通指针所造成的内存泄漏"></a>普通指针所造成的内存泄漏</h2><p>举个很简单的例子，如下是一个很简单的Demo类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Demo</span>(std::string demo = <span class="string">&quot;origin&quot;</span>) :<span class="built_in">name</span>(demo)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Demo :&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;的构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Demo</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Demo :&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;的析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;这是Demo：&quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>随后我们在main函数中，分别创建一个临时变量和new一个堆区变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Demo <span class="title">d1</span><span class="params">(<span class="string">&quot;demo1&quot;</span>)</span></span>;<span class="comment">//存储在栈区</span></span><br><span class="line">d1.<span class="built_in">get_info</span>();</span><br><span class="line"></span><br><span class="line">Demo* d2 = <span class="keyword">new</span> Demo;<span class="comment">//存储在堆区</span></span><br><span class="line">d2-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>程序的运行结果会显示，主程序调用了两次构造函数，但只调用了一次析构函数。原因是栈区空间的管理由操作系统负责，他会在程序运行出该变量的作用域后释放对象的空间，而堆上的空间由程序员负责，只有当程序完全结束后，操作系统才会进行回收。当程序长时间运行时（例如服务器）那些申请了堆区空间但却无法得到正确释放的变量会消耗大量的内存，最终堆栈溢出。</p>
<h2 id="C-98中的auto-ptr-已弃用"><a href="#C-98中的auto-ptr-已弃用" class="headerlink" title="C++98中的auto_ptr(已弃用)"></a>C++98中的auto_ptr(已弃用)</h2><p>auto_ptr 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存。</p>
<p>使用auto_ptr可以实现当变量度过自己的生存周期以后，编译器自动的销毁变量所申请的堆区空间。在运行时，有些编译器会报出如下错误： warning: ‘template<class> class std::auto_ptr’ is deprecated；而有的编译器只会直接报错。这是因为auto_ptr在c++11版本就被弃用了，c++11更推荐使用unique_ptr来代替。auto_ptr之所以会被弃用，主要是对于auto_ptr，如果进行拷贝或者赋值时，被拷贝的auto_ptr或者等号右边的auto_ptr会被释放掉。例如对于同是auto_ptr的p1和p2来说，当执行p1&#x3D;p2时，会先将p1原来托管的指针释放掉，然后再接受p2所托管的指针，随后p2所托管的指针置空。这在程序中是非常重大的错误。所以后续c++使用更严谨的unique_ptr来代替。</class></p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr最大的特点就是独占。即同一时间内，该指针只能被一个unique_ptr托管（即不能进行左值赋值和拷贝）。当变量生存周期结束时，会自动释放对象所占内存。</p>
<p>使用语句<code>unique_ptr&lt;Demo&gt; d1 = make_unique&lt;Demo&gt;(&quot;demo1&quot;);</code>后，结果会显示构造函数和析构函数都执行了。说明unique_ptr实现了对动态内存的管理。</p>
<h3 id="unique-ptr的三种构造方式"><a href="#unique-ptr的三种构造方式" class="headerlink" title="unique_ptr的三种构造方式"></a>unique_ptr的三种构造方式</h3><h4 id="1-通过原有指针构造"><a href="#1-通过原有指针构造" class="headerlink" title="1.通过原有指针构造"></a>1.通过原有指针构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo* d1 = <span class="keyword">new</span> <span class="built_in">Demo</span>(<span class="string">&quot;demo1&quot;</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">u_p_d1</span><span class="params">(d1)</span></span>;<span class="comment">//使用u_p_d1对d1进行托管</span></span><br><span class="line">u_p_d1-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>我们将d1的指针绑定到<code>unique_ptr&lt;Demo&gt; u_p_d1</code>，但是我们并没有剥夺d1的权利，d1仍然可以使用，也可以正常调用成员函数等。当使用如下语句时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Demo* d1 = <span class="keyword">new</span> <span class="built_in">Demo</span>(<span class="string">&quot;demo1&quot;</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">u_p_d1</span><span class="params">(d1)</span></span>;</span><br><span class="line">u_p_d1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">d1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;change_demo1&quot;</span>);</span><br><span class="line">u_p_d1-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>我们可以发现，d1仍可以正常调用Demo的成员函数set_name，而这与unique_ptr的设计理念相悖。所以正确的做法应该是当使用智能指针对初始指针进行托管后，要将初始指针进行“释放”。这里的释放并不是直接delete原指针，而是先将原指针置空后再delete。(顺序相反会将原指针所指向的内容都删除了)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Demo* d1 = <span class="keyword">new</span> <span class="built_in">Demo</span>(<span class="string">&quot;demo1&quot;</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">u_p_d1</span><span class="params">(d1)</span></span>;</span><br><span class="line">d1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> d1;</span><br><span class="line">u_p_d1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">d1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;change_demo1&quot;</span>);<span class="comment">//这行语句会在运行时报错</span></span><br><span class="line">u_p_d1-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-通过new直接构造"><a href="#2-通过new直接构造" class="headerlink" title="2..通过new直接构造"></a>2..通过new直接构造</h4><p>可以直接使用new的对象来构造unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">u_p_d2</span><span class="params">(<span class="keyword">new</span> Demo(<span class="string">&quot;demo2&quot;</span>))</span></span>;</span><br><span class="line">u_p_d2-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<h4 id="3-使用make-unique构造"><a href="#3-使用make-unique构造" class="headerlink" title="3.使用make_unique构造"></a>3.使用make_unique构造</h4><p>当然，c++更推荐使用make_unique函数来创建unique_ptr对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; u_p_d3 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo3&quot;</span>);</span><br><span class="line">u_p_d3-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>值得一说的是，unique_ptr是c++11版本提出，而make_unique是c++14才出现。make_ptr使得智能指针的写法更规范（至少明面上看不到new了）。其简单版实现大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr的一些特性"><a href="#unique-ptr的一些特性" class="headerlink" title="unique_ptr的一些特性"></a>unique_ptr的一些特性</h3><h4 id="赋值与拷贝"><a href="#赋值与拷贝" class="headerlink" title="赋值与拷贝"></a>赋值与拷贝</h4><p>unique_ptr由于其独占特性，我们不能对其进行左值赋值或者拷贝，但能进行临时右值拷贝和赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; dd1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demodd1&quot;</span>);</span><br><span class="line">unique_ptr&lt;Demo&gt; dd2 = dd1;<span class="comment">//错误，无法进行左值赋值</span></span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">dd3</span><span class="params">(dd1)</span></span>;<span class="comment">//错误，无法进行左值拷贝</span></span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">dd4</span><span class="params">(move(dd1))</span></span>;<span class="comment">//正确，可以进行右值拷贝</span></span><br><span class="line">unique_ptr&lt;Demo&gt; dd2 = <span class="built_in">move</span>(dd1);<span class="comment">//正确，可以进行右值赋值，但此行语句与上一条语句只能出现一个</span></span><br></pre></td></tr></table></figure>

<p>move函数将一个unique_ptr指针所指向内存的控制权限移动（交给）给另一个unique_ptr指针，此时原来的unique_ptr指针就置为nullptr（且根据使用move函数的规则，你一旦移动完之后，就不能再对原来的指针做任何事情了）</p>
<h4 id="release和reset函数"><a href="#release和reset函数" class="headerlink" title="release和reset函数"></a>release和reset函数</h4><p>release函数使得uniqe_ptr放弃对原有指针的托管即指针的管理权，返回原始指针，同时将该unique_ptr置为空。使用这个语句以后，指针的内存管理又回到了程序员手中，需要在恰当时机释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demod1&quot;</span>);</span><br><span class="line">Demo* dd1 = d1.<span class="built_in">release</span>();<span class="comment">//使用.而不是-&gt;</span></span><br><span class="line">dd1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line"><span class="keyword">delete</span> dd1;</span><br></pre></td></tr></table></figure>

<p>reset函数能将一个已经绑定了一个指针的unique_ptr重新绑定到另一个unique_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d2 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demodd2&quot;</span>);</span><br><span class="line">d2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Demo</span>(<span class="string">&quot;dd2&quot;</span>));</span><br><span class="line">d2-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>在上诉例子中，执行reset，会将最开始unique_ptr d2所指向的demodd2内存释放，然后将新的demo  dd2绑定到d2上。</p>
<p>我们可以通过这两个函数连用，实现某种意义上的unique_ptr的赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">unique_ptr&lt;Demo&gt; d2 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo22&quot;</span>);</span><br><span class="line">d1.<span class="built_in">reset</span>(d2.<span class="built_in">release</span>());</span><br><span class="line">d1-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>使用这种操作可以将demo22的托管权交由d1。但是demo22这个对象会被释放。</p>
<h4 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h4><p>可以使用swap函数将两个unique_ptr所托管的指针进行交换。两种类型的swap都可以实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">unique_ptr&lt;Demo&gt; d2 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo22&quot;</span>);</span><br><span class="line"><span class="built_in">swap</span>(d1, d2); <span class="comment">//使用全局函数swap</span></span><br><span class="line">d1.<span class="built_in">swap</span>(d2); <span class="comment">//使用成员函数swap</span></span><br><span class="line">d1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">d2-&gt;<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<h4 id="unique-ptr指向数组？"><a href="#unique-ptr指向数组？" class="headerlink" title="unique_ptr指向数组？"></a>unique_ptr指向数组？</h4><p>若unique_ptr要指示数组时，可以使用如下两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unique_ptr&lt;Demo[]&gt; arr(new Demo[9]);这个也可以</span></span><br><span class="line">unique_ptr&lt;Demo[]&gt; arr = <span class="built_in">make_unique</span>&lt;Demo[]&gt;(<span class="number">9</span>);<span class="comment">//括号里面9表示数组大小</span></span><br><span class="line">arr[<span class="number">8</span>].<span class="built_in">get_info</span>();</span><br></pre></td></tr></table></figure>

<p>当arr结束生命周期时，该数组中所有元素的空间都将被释放。</p>
<h4 id="unique-ptr-x3D-nullptr？"><a href="#unique-ptr-x3D-nullptr？" class="headerlink" title="unique_ptr &#x3D; nullptr？"></a>unique_ptr &#x3D; nullptr？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">d1 = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------&quot;</span>;<span class="comment">//标识程序的末尾</span></span><br></pre></td></tr></table></figure>

<p>值得一说的是，将一个unique_ptr置空会导致所托管的指针所指内容也被释放。上面demo11的析构函数会在cout之前被调用。</p>
<h4 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h4><p>get函数会返回该智能指针托管的原指针地址（尽量别这样干）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">Demo* dd2 = d1.<span class="built_in">get</span>();</span><br><span class="line"><span class="comment">//d1.reset();</span></span><br><span class="line"><span class="comment">//d1 = nullptr;</span></span><br><span class="line">dd2-&gt;<span class="built_in">get_info</span>(); <span class="comment">//dd2可以调用成员函数</span></span><br><span class="line"><span class="keyword">delete</span> dd2;<span class="comment">//不要这样干，会导致重复删除同一内存空间</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;Demo&gt; d2(dd2);</span></span><br><span class="line">unique_ptr&lt;Demo&gt; d2;</span><br><span class="line"><span class="comment">//d2.reset(dd2);</span></span><br></pre></td></tr></table></figure>

<p>我们发现，当使用dd2接受get的返回值后，dd2也能正常调用成员函数，这显然违反了unique-ptr的设计理念。在进一步的实验中我们发现，即使dd2通过get得到了原有指针的值，但随着智能指针的reset或者置空(这两个操作都会将unique_ptr所绑定的指针所指对象内存释放)，dd2将不再能调用成员函数(其实是所访问的内存空间不存在了)。</p>
<p>我们可以delete通过get函数返回后的指针，但这会导致unique_ptr在变量生存周期结束时对同一内存区域进行删除(已经删除过一次了)。</p>
<p>值得一说的是，我们也不能将通过get得来的原始指针来绑定另一个unique_ptr（无论是拷贝还是使用reset）。get()函数在使用时一定要注意使用的后果，不要使用get返回后的指针来为另一个智能指针赋值，最好也不要通过这个指针来对对象进行修改。</p>
<h3 id="unique-ptr作参数"><a href="#unique-ptr作参数" class="headerlink" title="unique_ptr作参数"></a>unique_ptr作参数</h3><h4 id="作形参值传递"><a href="#作形参值传递" class="headerlink" title="作形参值传递"></a>作形参值传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(unique_ptr&lt;Demo&gt; p)</span><span class="comment">//值传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">	<span class="comment">//func(d1);调用失败</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="built_in">move</span>(d1));</span><br><span class="line">	d1-&gt;<span class="built_in">get_info</span>();<span class="comment">//会失败</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当unique_ptr作形参进行值传递时，我们不能直接将一个unique_ptr作为参数传入。编译器会给出错误：无法引用 函数 “std::unique_ptr&lt;_Ty, _Dx&gt;::unique_ptr(const std::unique_ptr&lt;_Ty, _Dx&gt; &amp;)  – 它是已删除的函数。</p>
<p>我们知道，在函数进行值传递时，编译器会调用该对象的拷贝构造函数，构造出一个临时变量作为形参传入函数中，而unique_ptr删除了拷贝构造函数，所以在调用时，由于编译器找不到拷贝构造函数，所以此处函数调用失败。我们只需要使用移动语义move，将整个指针的控制权也转移到形参，这样函数就能正常调用。但这样做的代价就是，当函数执行完毕，该unique_ptr所指内存区域就会被自动释放(函数体内就是他的生存空间)，在外界我们将无法再对其进行任何操作。</p>
<h4 id="作形参引用传递"><a href="#作形参引用传递" class="headerlink" title="作形参引用传递"></a>作形参引用传递</h4><p>使用引用传递能完美解决以上的不足</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(unique_ptr&lt;Demo&gt;&amp; p)</span><span class="comment">//引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> Demo);<span class="comment">//可以重新绑定新的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unique_ptr&lt;Demo&gt; d1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;demo11&quot;</span>);</span><br><span class="line">	<span class="built_in">func</span>(d1);</span><br><span class="line">	d1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不仅能实现直接传递，不使用移动语义，同时函数退出以后，也能继续对其正常操作。</p>
<p>值得一说的是，此时在函数体中对demo11的更改（包含但不限于对象自带的成员函数以及reset(),swap()等），也会反应到主函数中。</p>
<h4 id="作返回值"><a href="#作返回值" class="headerlink" title="作返回值"></a>作返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unique_ptr&lt;Demo&gt;d1 = <span class="built_in">func</span>(<span class="string">&quot;demo11&quot;</span>);<span class="comment">//右值赋值</span></span><br><span class="line">	d1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然unique_ptr不支持左值拷贝构造，但支持右值的拷贝构造，当unique_ptr作为返回值类型时，return的对象是个临时右值，此时可以进行拷贝构造或者赋值。</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr是一种共享型智能指针，即可以多个shared_ptr绑定同一个指针，在shared_ptr内部采用引用计数来统计绑定该指针的shared_ptr数量（使用成员函数use_count查看），当引用计数为0时，就会释放掉该指针所指空间。</p>
<h3 id="shared-ptr的三种构造方式"><a href="#shared-ptr的三种构造方式" class="headerlink" title="shared_ptr的三种构造方式"></a>shared_ptr的三种构造方式</h3><h4 id="1-通过原有指针构造-1"><a href="#1-通过原有指针构造-1" class="headerlink" title="1.通过原有指针构造"></a>1.通过原有指针构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo* d = <span class="keyword">new</span> <span class="built_in">Demo</span>(<span class="string">&quot;demoss1&quot;</span>);</span><br><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">ss1</span><span class="params">(d)</span></span>;<span class="comment">//正确</span></span><br><span class="line">d-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;ss2&quot;</span>);</span><br><span class="line"><span class="comment">//shared_ptr&lt;Demo&gt; ss2 = d;//错误</span></span><br><span class="line">ss1-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>shared_ptr可以通过普通指针直接拷贝构造，不可以将普通指针赋值给一个shared_ptr，因为其运算符&#x3D;的重载中并不包含普通指针。</p>
<p>值得一说的是，尽管这样我们能构造成功，但ss1的use_count为1，但实际上，除了通过ss1来访问内存空间外，最开始的d也可以正常访问成员函数。这是我们需要格外注意的一点。当我们将一个指针绑定到一个shared_ptr后，我们因将该指针全权交由其管理，从而保证内存空间的安全。</p>
<h4 id="2-通过new直接构造-1"><a href="#2-通过new直接构造-1" class="headerlink" title="2.通过new直接构造"></a>2.通过new直接构造</h4><p>可以通过new的一个临时变量来构造shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">ss2</span><span class="params">(<span class="keyword">new</span> Demo(<span class="string">&quot;demoss2&quot;</span>))</span></span>;</span><br><span class="line">ss2-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">cout &lt;&lt; ss2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="3-通过make-shared构造"><a href="#3-通过make-shared构造" class="headerlink" title="3.通过make_shared构造"></a>3.通过make_shared构造</h4><p>make_shared是c++14提供的构造函数，这是最安全，也是最高效的方法。我们应该尽量使用这种方法来构造shared_ptr.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss3 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;demoss3&quot;</span>);</span><br><span class="line">ss3-&gt;<span class="built_in">get_info</span>();</span><br><span class="line">cout &lt;&lt; ss3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr的一些特性"><a href="#shared-ptr的一些特性" class="headerlink" title="shared_ptr的一些特性"></a>shared_ptr的一些特性</h3><h4 id="shared-ptr的引用计数"><a href="#shared-ptr的引用计数" class="headerlink" title="shared_ptr的引用计数"></a>shared_ptr的引用计数</h4><p>shared_ptr是计数共享智能指针，在使用shared_ptr时，shared_ptr对象不仅保存着原始指针，还保存这一个count，当有另一个shared_ptr共享这块内存时，count就加一，当有shared_ptr对象放弃该块内存的托管时，count就减一。</p>
<p>我们很容易发现，绑定同一内存地址的shared_ptr共享一个count，为了实现这个要求，一般count都会被放在堆上（不能采用类内static）。我们可以通过函数use_count来获取某块内存的shared_ptr共享数。在shared_ptr的各操作中，拷贝、赋值、置空和reset函数会导致shared_ptr的计数改变（这会导致某些shared_ptr释放内存）。</p>
<p>值得一说的是，shared_ptr中没有release函数，swap函数也并不会改变其内部的引用计数。</p>
<h4 id="shared-ptr的拷贝、赋值、reset"><a href="#shared-ptr的拷贝、赋值、reset" class="headerlink" title="shared_ptr的拷贝、赋值、reset"></a>shared_ptr的拷贝、赋值、reset</h4><p>不同于unique_ptr,shared_ptr支持左值的拷贝与赋值，当这样干时，该shared_ptr的引用计数将会加一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;demoss1&quot;</span>);</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">ss2</span><span class="params">(ss1)</span></span>;</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//2</span></span><br><span class="line">shared_ptr&lt;Demo&gt; ss3 = ss1;</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>当拷贝和赋值都完成后，ss1的引用计数为3（ss2和ss3的引用计数也会变成3）。</p>
<p>shared_ptr也支持右值拷贝与赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;demoss1&quot;</span>);</span><br><span class="line">Demo* ss1 = <span class="keyword">new</span> Demo;<span class="comment">//只能被拷贝，无法赋值给shared_ptr。</span></span><br><span class="line"><span class="function">unique_ptr&lt;Demo&gt; <span class="title">ss1</span><span class="params">(<span class="keyword">new</span> Demo)</span></span>;</span><br><span class="line">shared_ptr&lt;Demo&gt; ss3 = <span class="built_in">move</span>(ss1);</span><br><span class="line">cout &lt;&lt; ss3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>我们可以使用移动语义move将一个shared_ptr或unique_ptr对象转换为右值，然后赋值给另一个shared_ptr，值得一说的是，原始指针无法直接赋值给shared_ptr，但是可以被拷贝，语句<code>shared_ptr&lt;Demo&gt; ss3(move(ss1));</code>是正确的。</p>
<p>而当一个已经绑定了一个指针的shared_ptr赋值或拷贝另一个shared_ptr时，原来的shared_ptr对象的引用计数要进行减一，而新的shared_ptr的引用计数要加一。</p>
<p>reset函数当参数什么都不写时，表示将该shared_ptr释放（并不是释放所管理指针所指的内存，而是将引用计数减一）。当一个参数时（这个参数是普通指针，并不是shared_ptr，reset函数并没重载shared_ptr类型），会将该参数指针绑定到这个shared_ptr上。</p>
<p>上诉所有的操作，当某个shared_ptr所管理的内存空间的引用计数为0时，就会调用删除函数（默认是delete）来释放内存。</p>
<h4 id="shared-ptr-x3D-nullptr"><a href="#shared-ptr-x3D-nullptr" class="headerlink" title="shared_ptr &#x3D; nullptr?"></a>shared_ptr &#x3D; nullptr?</h4><p>令一个shared_ptr &#x3D; nullptr会将当前这个shared_ptr作废，使对应引用计数减一，当引用计数为0时，便会自动调用删除函数释放内存。</p>
<h4 id="shared-ptr与数组"><a href="#shared-ptr与数组" class="headerlink" title="shared_ptr与数组"></a>shared_ptr与数组</h4><p>可以采用以下方式来将shared_ptr绑定一个数组类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法，使用原有数组指针</span></span><br><span class="line">Demo* ss0 = <span class="keyword">new</span> Demo[<span class="number">4</span>];</span><br><span class="line"><span class="function">shared_ptr&lt;Demo[]&gt; <span class="title">ss1</span><span class="params">(ss0)</span></span>;</span><br><span class="line"><span class="comment">//第二种，通过new构建</span></span><br><span class="line"><span class="function">shared_ptr&lt;Demo[]&gt; <span class="title">ss1</span><span class="params">(<span class="keyword">new</span> Demo[<span class="number">5</span>])</span></span>;<span class="comment">//可以在new后边加上初始化列表实现数组初始化</span></span><br><span class="line"><span class="comment">//第三种，使用make_shared</span></span><br><span class="line">shared_ptr&lt;Demo[]&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo[]&gt;(<span class="number">5</span>);<span class="comment">//其中5指数组大小</span></span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>上面的实现需要在c++14版本以后使用。</p>
<h4 id="shared-ptr绑定类中的某个成员？"><a href="#shared-ptr绑定类中的某个成员？" class="headerlink" title="shared_ptr绑定类中的某个成员？"></a>shared_ptr绑定类中的某个成员？</h4><p>shared_ptr不仅可以绑定在一个类的指针上，也可以只绑定在类的某个成员上（属性不能是private）；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dd</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id = <span class="number">9</span>;</span><br><span class="line">	string name = <span class="string">&quot;zhang&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dd mydd;</span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt; ss1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(mydd.id);</span><br><span class="line">	cout &lt;&lt; *ss1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多的使用是像下面一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;dd&gt; ss2 = <span class="built_in">make_shared</span>&lt;dd&gt;();</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ss1</span><span class="params">(ss2, &amp;ss2-&gt;id)</span></span>;</span><br><span class="line"><span class="comment">//shared_ptr&lt;int&gt; ss1(&amp;ss2-&gt;id);错误，会导致重复delete</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ss3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(ss2-&gt;id);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ss1 的地址&quot;</span> &lt;&lt; ss1.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ss2 的地址&quot;</span> &lt;&lt; ss2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ss3 的地址&quot;</span> &lt;&lt; ss3.<span class="built_in">get</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>上诉代码运行结果为：</p>
<p>ss1 的地址000001E53C4ACE00<br>ss2 的地址000001E53C4ACE00<br>ss3 的地址000001E53C4B56A0</p>
<p>可以发现，ss1和ss2的地址是相同的（其实就是dd对象的地址），而ss3虽然也指向ss2下的id，但地址却和前两者都不一样，原因是ss1采用了别名构造函数。</p>
<p>其模板为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( shared_ptr&lt;Y&gt;&amp;&amp; r, element_type* ptr )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>别名使用构造函数</em>：构造 <code>shared_ptr</code> ，与 <code>r</code> 的初始值共享所有权信息，但保有无关且不管理的指针 <code>ptr</code> 。若此 <code>shared_ptr</code> 是离开作用域的组中的最后者，则它将调用最初 <code>r</code> 所管理对象的析构函数。然而，<strong>在此 <code>shared_ptr</code> 上调用 <code>get()</code> 将始终返回 <code>ptr</code> 的副本</strong>。程序员负责确保只要此 <code>shared_ptr</code> 存在，此 <code>ptr</code> 就保持合法，例如在典型使用情况中，其中 <code>ptr</code> 是 <code>r</code> 所管理对象的成员，或是 <code>r.get()</code> 的别名（例如向下转型）。对于接收右值的第二重载，调用后 <code>r</code> 为空且 r.get() &#x3D;&#x3D; nullptr 。 (C++20 起)</p>
<p>这就是上面ss1和ss2的地址相同的原因。我们还发现，如果我们采用很简单的拷贝过程，如使用<code>shared_ptr&lt;int&gt; ss1(&amp;ss2-&gt;id);</code>语句进行赋值时，编译期阶段我们不会发现错误，也能正常使用这个指针，我们甚至可以求出ss1的原始指针（通过get）和ss2一致。但当其生存周期结束以后，这两个shared_ptr会进行重复的删除工作（因为这两个指针互不相干，有着独立的引用计数都为1）。而使用别名构造函数，虽然两个shared_ptr的类型都不相同，但是两者却共享一个引用计数，即两者的count都为2，所以在删除时不会出现重复删除的问题。</p>
<h4 id="get函数与shared-ptr的一个陷阱"><a href="#get函数与shared-ptr的一个陷阱" class="headerlink" title="get函数与shared_ptr的一个陷阱"></a>get函数与shared_ptr的一个陷阱</h4><p>get函数可以获取shared_ptr所绑定的指针的真实地址。在c++ prime中有句忠告是;不要使用get（）初始化shared_ptr。这是为什么呢？原因是这样使用会有很大风险。最主要的一个问题就是重复的删除。</p>
<p>样例如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;dess1&quot;</span>);</span><br><span class="line">Demo* p1 = ss1.<span class="built_in">get</span>();</span><br><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">ss2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//结果为1</span></span><br><span class="line">cout &lt;&lt; ss2.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure>

<p>当我们使用get（）获取到的指针再去构造一个shared_ptr时，虽然我们能构造成功，但是此时两个shared_ptr的引用计数都是1，但是两者却有管理着同一块内存，管理权出现了冲突，如果此时其中一个shared_ptr由于引用计数为0释放了所管理的内存空间，那么另一个shared_ptr将无法进行使用，从而发生错误。</p>
<p>因此我们在使用get（）时，一定不要轻易对返回的指针进行操作，更不要用这个指针去初始化构造另一个shared_ptr。</p>
<h4 id="和unique-ptr的转换"><a href="#和unique-ptr的转换" class="headerlink" title="和unique_ptr的转换"></a>和unique_ptr的转换</h4><p>由于unique_ptr的语义是唯一拥有，那只要对他执行move操作就能把管理权转移出去给shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;Demo&gt; uu1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;dduu1&quot;</span>);</span><br><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">ss1</span><span class="params">(move(uu1))</span></span>;<span class="comment">//使用move直接转移管理权</span></span><br><span class="line">shared_ptr&lt;Demo&gt; ss2 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;dduu2&quot;</span>);<span class="comment">//可以隐式转换为shared_ptr</span></span><br></pre></td></tr></table></figure>

<p>而shared_ptr到unique_ptr不允许。一旦将资源的生命周期管理转移到shared_ptr，就不能改变到unique_ptr。即使引用计数为1，也无法收回对资源的所有权以进行unique_ptr管理。</p>
<h3 id="shared-ptr作参数"><a href="#shared-ptr作参数" class="headerlink" title="shared_ptr作参数"></a>shared_ptr作参数</h3><h4 id="作形参值传递-1"><a href="#作形参值传递-1" class="headerlink" title="作形参值传递"></a>作形参值传递</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;Demo&gt; p)</span><span class="comment">//值传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func中&quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ddss1&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用前&quot;</span> &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>(ss1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用后&quot;</span> &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	unique_ptr&lt;Demo&gt; uu1 = <span class="built_in">make_unique</span>&lt;Demo&gt;(<span class="string">&quot;dduu1&quot;</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="built_in">move</span>(uu1));<span class="comment">//unique_ptr移交管理权</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上诉运行结果为：</p>
<p>Demo :ddss1的构造函数<br>调用前1<br>func中2<br>调用后1<br>Demo :dduu1的构造函数<br>func中1<br>Demo :dduu1的析构函数<br>Demo :ddss1的析构函数</p>
<p>在值传递中，如果传入参数是一个shared_ptr，那么拷贝构造一个新的shared_ptr，此时原来的shared_ptr的引用计数加一变成二，当函数体结束后，函数体将拷贝的那个shared_ptr“释放”，从而使得对应的引用计数减一。</p>
<p>而当传入参数为一个unique_ptr时，由于上面说过，unique_ptr可以使用转换为shared_ptr，所以语句是没有任何问题的。但是一旦将一个unique_ptr的管理权通过move转移到shared_ptr后，原来的unique_ptr将无法再使用，这是编程者需要明确的一个事情。同时，此shared_ptr的生存周期也仅在函数体内，一旦函数体执行完毕，该shared_ptr的引用计数就会减到0，从而释放掉所管理的内存空间。</p>
<h4 id="作形参引用传递-1"><a href="#作形参引用传递-1" class="headerlink" title="作形参引用传递"></a>作形参引用传递</h4><p>当将func函数的参数修改为引用类型时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(shared_ptr&lt;Demo&gt;&amp; p)</span><span class="comment">//引用传递</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func中&quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ddss1&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用前&quot;</span> &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>(ss1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用后&quot;</span> &lt;&lt; ss1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p>Demo :ddss1的构造函数<br>调用前1<br>func中1<br>调用后1<br>Demo :ddss1的析构函数</p>
<p>此时函数调用将不再进行拷贝构造，所以调用前后shared_ptr的引用计数都为1，由于参数为shared_ptr引用，所以将不再能接受unique_ptr类型，无论是使用其左值还是使用move转换为右值。</p>
<p>需要注意的是，程序员需要时刻注意引用传参不会增加shared_ptr的引用计数，也就是说，我们应当保证不要在函数体内将该shared_ptr所指内存释放。在此例中，如果我们在函数体中reset了shared_ptr p（引用计数减一，因为计数最开始只有1，所以减一变成0，自动释放内存）；那么会导致函数退出后，我们也无法继续使用ss1。</p>
<h4 id="作返回值-1"><a href="#作返回值-1" class="headerlink" title="作返回值"></a>作返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Demo&gt; <span class="title">func</span><span class="params">(string name = <span class="string">&quot;ssff1&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;Demo&gt;(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; ss1.<span class="built_in">use_count</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当shared_ptr作为返回值时，当执行到return语句时，函数体内生成的shared_ptr会进行一次拷贝，生成一个临时变量，此时引用计数会变成2，然后再将生成的临时变量返回到函数体外部，函数体中的shared_ptr自我销毁，在函数体外部，shared_ptr ss1会使用临时变量来进行初始化构造，当构造完成后，临时变量自我销毁，最终shared_ptr的引用计数为1。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr叫弱引用指针。是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。weak_ptr 设计的目的是为了协助shared_ptr而引入的一种智能指针,它可以解决shared_ptr循环引用的问题。<strong>weak_ptr只可以从一个shared_ptr或另一个 weak_ptr 对象来构造, 它的构造和析构不会引起引用记数的增加或减少。</strong></p>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>使用shared_ptr并不一定能保证内存管理的绝对安全，不恰当的使用也会造成内存空间的安全问题，最经典的就是循环引用问题。为了复现这个问题，我们再原有的Demo类中新增加一个数据成员</p>
<p><code>std::shared_ptr&lt;Demo&gt; d_friend;</code></p>
<p>以及一个成员函数</p>
<p><code>	void set_friend(std::shared_ptr&lt;Demo&gt; d_friend)     &#123;         this-&gt;d_friend = d_friend;     &#125;</code></p>
<p>这样的设计在现实层面很合理，但是当我们将两个对象通过set_friend进行练习时，就会出现一些错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ff1&quot;</span>);</span><br><span class="line">shared_ptr&lt;Demo&gt; ss2 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ff2&quot;</span>);</span><br><span class="line">ss1-&gt;<span class="built_in">set_friend</span>(ss2);</span><br><span class="line">ss2-&gt;<span class="built_in">set_friend</span>(ss1); <span class="comment">//朋友是双向的</span></span><br></pre></td></tr></table></figure>

<p>运行一下上面的代码，结果如下：</p>
<p>Demo :ff1的构造函数<br>Demo :ff2的构造函数</p>
<p>程序正常结束了，<strong>但ff1和ff2的内存空间并没有被释放！</strong>。我们不妨加入两条打印语句来检测一下这两个对象的引用计数。发现都是2。那程序没有正常自动释放掉内存空间的原因也就清晰了。当我们使用set_friend函数时，由于函数体内部做的赋值操作，这会导致作为参数传进来的shared_ptr的引用计数加一变成二。当ff1和ff2离开自己的生存域时（此例中是指主函数执行完），引用计数减一，但引用计数并不等于0，所以也就不会自动释放掉内存，从而造成内存泄露。当然解决办法，c++也给出来了，就是使用weak_ptr来替代shared_ptr，从而解决循环引用的问题。</p>
<h3 id="weak-ptr的构造"><a href="#weak-ptr的构造" class="headerlink" title="weak_ptr的构造"></a>weak_ptr的构造</h3><p>weak_ptr只可以从一个shared_ptr或另一个 weak_ptr 对象来构造, 它的构造和析构不会引起引用记数的增加或减少。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; ss1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ww1&quot;</span>);</span><br><span class="line">weak_ptr&lt;Demo&gt; ww1 = ss1;</span><br><span class="line"><span class="function">weak_ptr&lt;Demo&gt; <span class="title">ww1</span><span class="params">(ss1)</span></span>;  <span class="comment">//可以使用shared_ptr进行构造</span></span><br><span class="line"></span><br><span class="line">weak_ptr&lt;Demo&gt; ww2 = ww1;</span><br><span class="line"><span class="function">weak_ptr&lt;Demo&gt; <span class="title">ww2</span><span class="params">(ww1)</span></span>;<span class="comment">//也可以使用weak_ptr进行构造</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ww1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ww2.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure>

<p>weak_ptr也可以使用use_count来查看共享引用计数，但是自身无法改变引用计数。</p>
<h3 id="如何解决的循环引用？"><a href="#如何解决的循环引用？" class="headerlink" title="如何解决的循环引用？"></a>如何解决的循环引用？</h3><p>我们只需要将Demo类中的d_friend类型改为weak_ptr，即<code>	std::weak_ptr&lt;Demo&gt; d_friend;</code>，那么再次运行程序，结果就会是：</p>
<p>Demo :ff1的构造函数<br>Demo :ff2的构造函数<br>1<br>1<br>Demo :ff2的析构函数<br>Demo :ff1的析构函数</p>
<p>ff1和ff2在互相设置为friend以后，引用计数仍然是1（因为weak_ptr并不对引用计数进行增减）。所以当他们结束生存周期以后，能够正确释放掉他们所申请的动态内存。</p>
<h3 id="使用时最好先expired判断是否有效"><a href="#使用时最好先expired判断是否有效" class="headerlink" title="使用时最好先expired判断是否有效"></a>使用时最好先expired判断是否有效</h3><p>在使用weak_ptr之前，尽量先使用expired函数判断当前智能指针是否还有托管的对象，<strong>有则返回false，无则返回true</strong>(不要记反了)！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; ww1;</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; ww2;</span><br><span class="line">&#123;</span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt; pp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">	ww1 = pp1;<span class="comment">//这是一个作用域，当这个语句块结束后，pp1管理的内存就会被自动释放</span></span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; pp2 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">ww2 = pp2;</span><br><span class="line"><span class="keyword">if</span> (ww1.<span class="built_in">expired</span>())</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;weak_ptr ww1无效&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;weak_ptr  ww1有效&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (ww2.<span class="built_in">expired</span>())</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;weak_ptr  ww2无效&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;weak_ptr  ww2有效&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>上诉代码的结果是：</p>
<p>weak_ptr ww1无效<br>weak_ptr  ww2有效</p>
<h3 id="lock函数"><a href="#lock函数" class="headerlink" title="lock函数"></a>lock函数</h3><p> lock()函数返回一个指向共享对象的shared_ptr，同时引用计数加一。如果对象被释放，则返回一个空shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; pp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; ww1 = pp1;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; pp2 = ww1.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; pp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ww1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此时ww1并不会被销毁，ww1和pp2以及pp1的引用计数都是2。</p>
<h3 id="消除一个weak-ptr-reset？或-x3D-nullptr？"><a href="#消除一个weak-ptr-reset？或-x3D-nullptr？" class="headerlink" title="消除一个weak_ptr,reset？或&#x3D;nullptr？"></a>消除一个weak_ptr,reset？或&#x3D;nullptr？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; dd1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ww1&quot;</span>);</span><br><span class="line">weak_ptr&lt;Demo&gt; ww1 = dd1;</span><br><span class="line">ww1.<span class="built_in">reset</span>();</span><br><span class="line"><span class="comment">//ww1 = nullptr;</span></span><br><span class="line">cout &lt;&lt; ww1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;<span class="comment">//分割线，查看析构的执行时机</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用reset函数（里面不加任何参数）来将一个weak_ptr解除绑定。weak_ptr不能置为nullptr，编译器会直接报错：</p>
<p>二元“&#x3D;”: 没有找到接受“nullptr”类型的右操作数的运算符(或没有可接受的转换)</p>
<p>使用reset解除绑定时，并不会对引用计数进行减一，所以不会造成内存释放。</p>
<h2 id="类中通过shared-ptr返回this指针（weak-ptr实现）"><a href="#类中通过shared-ptr返回this指针（weak-ptr实现）" class="headerlink" title="类中通过shared_ptr返回this指针（weak_ptr实现）"></a>类中通过shared_ptr返回this指针（weak_ptr实现）</h2><p>这个应该放在shared_ptr作返回值内容中，但由于使用到weak_ptr的内容，所以放在了后面进行分析。</p>
<h4 id="错误做法"><a href="#错误做法" class="headerlink" title="错误做法"></a>错误做法</h4><p>首先我们先在Demo类中定义这样的一个函数</p>
<p><code>	std::shared_ptr&lt;Demo&gt; get()     &#123;         return std::shared_ptr&lt;Demo&gt;(this);     &#125;</code></p>
<p>此函数将返回一个以this作为拷贝的shared_ptr对象。</p>
<p>在主函数中，我们这样调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; dd1 = <span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="string">&quot;ww1&quot;</span>);</span><br><span class="line">	shared_ptr&lt;Demo&gt; gg1;</span><br><span class="line">	gg1 = dd1-&gt;<span class="built_in">get</span>();<span class="comment">//调用get</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl; <span class="comment">//标识main函数结束</span></span><br></pre></td></tr></table></figure>

<p>运行这个程序我们发现，程序崩溃了，原因是进行了重复的删除。</p>
<p>因为this指针在某种程度上来说也是一个原始指针，样例中的dd1，通过make_shared函数绑定到了这个Demo ww1的内存空间上，此时这块空间引用计数为1，而成员函数get通过this指针构造了一个shared_ptr,虽然是绑定到同一个内存区域，但是他们直接并不知道，此时返回的这个shared_ptr的引用计数也是为1。当这两个shared_ptr中的其中一个结束了生命周期，就会释放掉Demo  ww1的内存空间，而另一个shared_ptr就无法再进行操作了。</p>
<h4 id="使用shared-from-this"><a href="#使用shared-from-this" class="headerlink" title="使用shared_from_this()"></a>使用shared_from_this()</h4><p>c++为我们提供了处理上诉问题的方法，即使用shared_from_this()。所有需要在内部传递this指针的类，都从enable_shared_from_this继承；在需要传递this的时候，使用其成员函数shared_from_this()来返回一个shared_ptr。</p>
<p>我们修改我们的Demo类:</p>
<p><code>class Demo : public std::enable_shared_from_this&lt;Demo&gt;</code>公有继承enable_shared_from_this</p>
<p>然后成员函数更改为：</p>
<p><code>std::shared_ptr&lt;Demo&gt; get()     &#123;         return shared_from_this();     &#125;</code></p>
<p>这样再执行main函数就能正常运行了。值得一说的是，如果要使用shared_from_this()这种方法，我们就必须保证类的对象已经被shared_ptr接管。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Demo&gt; dd1 = make_shared&lt;Demo&gt;(&quot;ww1&quot;);//正确</span><br><span class="line">//Demo* dd1 = new Demo; 错误</span><br><span class="line">shared_ptr&lt;Demo&gt; gg1;</span><br><span class="line">gg1 = dd1-&gt;get();</span><br><span class="line">cout &lt;&lt; &quot;------------&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，如果Demo  ww1没有被shared_ptr接管，而是使用简单的new，那么在执行shared_from_this()时会报错。这是因为只有shared_ptr的构造函数才能初始化enable_shared_from_this相关的内容（原理是weak_ptr只能通过shared_ptr进行构造），所以如果对象没有被shared_ptr管理，shared_from_this()函数就会出错。</p>
<p>我们再来看看为什么使用这种方法可以避免内存泄露。</p>
<p>我们点开std::enable_shared_from_this的源码（只截取相关部分）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123; <span class="comment">// provide member functions that create shared_ptr to this</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;_Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD shared_ptr&lt;<span class="type">const</span> _Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Ty&gt;(_Wptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>首先，std::enable_shared_from_this类中有一个weak_ptr，这个weak_ptr用来绑定this指针，调用shared_from_this()将weak_ptr构造成shared_ptr返回。这种构造方法会调用weak_ptr的lock方法，将weak_ptr所绑定的shared_ptr返回，并将其引用计数加一。所以当上诉例子执行完get以后，两个shared_ptr指向了同一个内存空间，并且引用计数都为2，当退出生存周期后，就能正常进行内存释放。</p>
<p>总结起来就是</p>
<ol>
<li><strong>若要在内部传递this，请考虑从enable_shared_from_this继承</strong></li>
<li><strong>若从enable_shared_from_this继承，则类对象必须让shared_ptr接管。</strong></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++的内存管理是一个很复杂的话题，指针在给予我们对内存的自由操纵权的同时，也把管理内存这件头大的事扔给了我们。内存错误是极其难发现和解决的。所以我们在设计之初就应当尽量避免出现内存问题。下面给出一些关于智能指针的总结。</p>
<ol>
<li>智能指针并不是万能的，如果操作不恰当，同样会造成内存泄漏。</li>
<li>整个项目指针应该统一，要么全使用原始指针自己管理，要么全使用智能指针</li>
<li>尽量使用make_unique和make_shared，而不是使用已有的原始指针去初始化智能指针</li>
<li><strong>不要使用多个unique_ptr绑定同一个原始指针</strong></li>
<li>使用release函数时，应接收返回值，因为release不会释放内存，只是返回管理权，如果不对其进行保存，这块内存将无法被任何方法找到，内存也就泄漏了。</li>
<li><strong>不要delete智能指针get函数返回的指针</strong></li>
<li><strong>不要使用智能指针get函数返回的指针去初始化任何智能指针</strong></li>
<li>注意循环引用问题</li>
</ol>
<p>智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">柴</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/99c27b28.html">http://example.com/post/99c27b28.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">孤岛</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a17b1dd0.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">力扣-剑指 Offer 30.包含min函数的栈(最小栈)</div></div></a></div><div class="next-post pull-right"><a href="/post/9bbc6cc6.html"><img class="next-cover" src="/img/p8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">B+树的C/C++实现</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/chai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">柴</div><div class="author-info__description">我们每个人都是一座孤岛</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>拍拍头</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了C++！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">C++智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E6%89%80%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">普通指针所造成的内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-98%E4%B8%AD%E7%9A%84auto-ptr-%E5%B7%B2%E5%BC%83%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">C++98中的auto_ptr(已弃用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.4.</span> <span class="toc-text">unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">unique_ptr的三种构造方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E5%8E%9F%E6%9C%89%E6%8C%87%E9%92%88%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1.通过原有指针构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87new%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2..通过new直接构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8make-unique%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">3.使用make_unique构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">unique_ptr的一些特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">赋值与拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#release%E5%92%8Creset%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">release和reset函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swap%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">swap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">unique_ptr指向数组？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr-x3D-nullptr%EF%BC%9F"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">unique_ptr &#x3D; nullptr？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">get函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">unique_ptr作参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E5%BD%A2%E5%8F%82%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">作形参值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E5%BD%A2%E5%8F%82%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">作形参引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">作返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.5.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">shared_ptr的三种构造方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E5%8E%9F%E6%9C%89%E6%8C%87%E9%92%88%E6%9E%84%E9%80%A0-1"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.通过原有指针构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87new%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0-1"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">2.通过new直接构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87make-shared%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">3.通过make_shared构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.2.</span> <span class="toc-text">shared_ptr的一些特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">shared_ptr的引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81reset"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">shared_ptr的拷贝、赋值、reset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr-x3D-nullptr"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">shared_ptr &#x3D; nullptr?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">shared_ptr与数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%BB%91%E5%AE%9A%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E6%88%90%E5%91%98%EF%BC%9F"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">shared_ptr绑定类中的某个成员？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E5%87%BD%E6%95%B0%E4%B8%8Eshared-ptr%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">get函数与shared_ptr的一个陷阱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8Cunique-ptr%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">和unique_ptr的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">shared_ptr作参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E5%BD%A2%E5%8F%82%E5%80%BC%E4%BC%A0%E9%80%92-1"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">作形参值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E5%BD%A2%E5%8F%82%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-1"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">作形参引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">作返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.6.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">循环引用问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">weak_ptr的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">如何解决的循环引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%80%E5%A5%BD%E5%85%88expired%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">1.6.4.</span> <span class="toc-text">使用时最好先expired判断是否有效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.5.</span> <span class="toc-text">lock函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E4%B8%80%E4%B8%AAweak-ptr-reset%EF%BC%9F%E6%88%96-x3D-nullptr%EF%BC%9F"><span class="toc-number">1.6.6.</span> <span class="toc-text">消除一个weak_ptr,reset？或&#x3D;nullptr？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E9%80%9A%E8%BF%87shared-ptr%E8%BF%94%E5%9B%9Ethis%E6%8C%87%E9%92%88%EF%BC%88weak-ptr%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">类中通过shared_ptr返回this指针（weak_ptr实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%81%9A%E6%B3%95"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">错误做法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8shared-from-this"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">使用shared_from_this()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/8f1c791d.html" title="和彤宝的2023年度总结"><img src="/img/p9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="和彤宝的2023年度总结"/></a><div class="content"><a class="title" href="/post/8f1c791d.html" title="和彤宝的2023年度总结">和彤宝的2023年度总结</a><time datetime="2024-02-06T03:32:59.000Z" title="发表于 2024-02-06 11:32:59">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"/></a><div class="content"><a class="title" href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)">力扣-剑指 Offer 30.包含min函数的栈(最小栈)</a><time datetime="2023-05-23T09:38:45.000Z" title="发表于 2023-05-23 17:38:45">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/99c27b28.html" title="C++智能指针"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针"/></a><div class="content"><a class="title" href="/post/99c27b28.html" title="C++智能指针">C++智能指针</a><time datetime="2023-03-29T08:01:21.000Z" title="发表于 2023-03-29 16:01:21">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9bbc6cc6.html" title="B+树的C/C++实现"><img src="/img/p8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+树的C/C++实现"/></a><div class="content"><a class="title" href="/post/9bbc6cc6.html" title="B+树的C/C++实现">B+树的C/C++实现</a><time datetime="2023-03-23T05:58:35.000Z" title="发表于 2023-03-23 13:58:35">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/827ca9cd.html" title="十大经典排序算法"><img src="/img/p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十大经典排序算法"/></a><div class="content"><a class="title" href="/post/827ca9cd.html" title="十大经典排序算法">十大经典排序算法</a><time datetime="2023-01-31T02:06:13.000Z" title="发表于 2023-01-31 10:06:13">2023-01-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 柴</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>