<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>孤岛</title><meta name="author" content="柴"><meta name="copyright" content="柴"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我们每个人都是一座孤岛">
<meta property="og:type" content="website">
<meta property="og:title" content="孤岛">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="我们每个人都是一座孤岛">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/chai.jpg">
<meta property="article:author" content="柴">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/chai.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '孤岛',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-06 17:11:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/chai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤岛</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">孤岛</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/post/8f1c791d.html" title="和彤宝的2023年度总结"><img class="post_bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="和彤宝的2023年度总结"></a></div><div class="recent-post-info"><a class="article-title" href="/post/8f1c791d.html" title="和彤宝的2023年度总结">和彤宝的2023年度总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-06T03:32:59.000Z" title="发表于 2024-02-06 11:32:59">2024-02-06</time></span></div><div class="content">开始​	从2023年7月24日，我们相识，到2024年2月5日，共196天28个星期。我们在微信上畅聊了130778条消息，其中还不包括各种链接和分享，我们是如此能聊，平均每天发送667条消息。相当于每小时就会发28条消息，如果排除睡觉和工作，上课时间，那我们平均每小时发的消息还要多得多！！！真是两个小话痨！
​	
消息频率分析下面对我们消息本身进行的分析。
类型分析从消息类型上看，彤宝更喜欢发送文字消息，而我更喜欢发送表情和图片，彤宝也更喜欢发送语音信息。由此来看，彤宝更喜欢和我进行有效的交流，而我大多数时候可能更喜欢使用表情包或者图片进行情感表达。

消息长度分析 从消息长度来看，我们大部分消息都集中在0-20字的区间，可以看到，彤宝更喜欢发送10个字以内的消息，用于表达情感或者需求，而我更喜欢发长句子来进行情感表述，这也或许印证了彤宝说的，我更喜欢“说教”。


每日活跃分析从每日活跃度上分析，我们都是夜聊一族，每天的活跃点在晚上11点到次日一点之前。因为白天大部分的时间，我在上班，晚上又会去玩游戏，完事以后就是十一点，然后我们才进行深入的聊天，但是我发现我们每天的每个时段都聊的 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"><img class="post_bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"></a></div><div class="recent-post-info"><a class="article-title" href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)">力扣-剑指 Offer 30.包含min函数的栈(最小栈)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-05-23T09:38:45.000Z" title="发表于 2023-05-23 17:38:45">2023-05-23</time></span></div><div class="content">题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
实现 MinStack 类:
MinStack() 初始化堆栈对象。void push(int val) 将元素val推入堆栈。void pop() 删除堆栈顶部的元素。int top() 获取堆栈顶部的元素。int getMin() 获取堆栈中的最小元素。
来源：力扣（LeetCode）链接：https://leetcode.cn/problems/min-stack
辅助栈辅助栈是最容易想到的办法，即使用两个栈来保存数据信息，一个栈用于保存数据的原始信息，另一个栈则用来动态的记录栈中元素的最小值。具体算法流程如下

push() 第一个栈正常push，将要push的元素x与第二个栈的栈顶元素比较，如果比栈顶元素(未插入前整个栈中的最小值)小，则将元素x，push进第二个栈中。
pop() 第一个栈正常pop(),将要弹出的元素x与第二个栈的栈顶比较，如果两者相等，则将第二个栈的栈顶元素一并弹出以维护最小值。
getMin()， 返回第二个栈的栈顶即可。

代码如下：
1234567891 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/99c27b28.html" title="C++智能指针"><img class="post_bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针"></a></div><div class="recent-post-info"><a class="article-title" href="/post/99c27b28.html" title="C++智能指针">C++智能指针</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-03-29T08:01:21.000Z" title="发表于 2023-03-29 16:01:21">2023-03-29</time></span></div><div class="content">C++智能指针前言​	我们知道C&#x2F;C++可以使用指针直接对数据内存进行操作，这给了程序员极大的操作空间的同时，也需要C&#x2F;C++程序员注意更多的细节。在程序运行时，每个程序有一个内存池，这部分内存存储程序动态分配的对象。当所申请的动态对象不再使用时，我们应该显式的销毁他们以防止内存泄漏。（不同于栈区空间操作系统自行管理）。智能指针的出现，就是为了协助程序员更好的管理堆区空间，从而避免内存泄漏！
普通指针所造成的内存泄漏举个很简单的例子，如下是一个很简单的Demo类的定义：
123456789101112131415161718192021class Demo &#123;public:	Demo(std::string demo = &quot;origin&quot;) :name(demo)	&#123;		std::cout &lt;&lt; &quot;Demo :&quot; &lt;&lt; name &lt;&lt; &quot;的构造函数&quot; &lt;&lt; std::endl;	&#125;	~Demo()	&#123;		std::cou ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/9bbc6cc6.html" title="B+树的C/C++实现"><img class="post_bg" src="/img/p8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+树的C/C++实现"></a></div><div class="recent-post-info"><a class="article-title" href="/post/9bbc6cc6.html" title="B+树的C/C++实现">B+树的C/C++实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-03-23T05:58:35.000Z" title="发表于 2023-03-23 13:58:35">2023-03-23</time></span></div><div class="content">B+树的c&#x2F;c++实现B+树概述B树数据查询几种方式我们知道如果要在一组数据中查询一个元素，我们可以使用顺序遍历，如果元素排好序时，还能使用二分查找提升查找的效率。但在数据域很大时，我们或许很难将所有数据放在一整块空间中，所以根据二分查找的思想，二叉查找树应运而生。而简单的二叉查找树在极端数据的情况下，查找效率会退化到顺序查找的O（n），这显然不是我们所期盼的，因此我们增加一些规则对其进行限制，于是形成了平衡二叉树，这保证树的高度尽量的矮（查找树的高度决定了查找元素的效率）。
在现实生活中，需要存储的数据很可能大大超出内存（我们也不能将内存全部使用来存储数据），大多数时候，我们都将数据存储在磁盘这些外围设备中，而计算机对磁盘的I&#x2F;O访问所需时间是很大的，为了保证数据查询的效率，我们需要尽可能的减少磁盘I&#x2F;O的次数，于是在查找树的基础上，B树产生了。
B树结构下面是一个B树的结构

其中有两类节点，一类是叶子节点，一类是非叶子节点，每个节点都是一个页，页就是一个磁盘空间。其中非叶子节点中有两个关键的成员，一个键值及数据数组，一个是儿子节点，其中一个非叶子节点 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/827ca9cd.html" title="十大经典排序算法"><img class="post_bg" src="/img/p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十大经典排序算法"></a></div><div class="recent-post-info"><a class="article-title" href="/post/827ca9cd.html" title="十大经典排序算法">十大经典排序算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-01-31T02:06:13.000Z" title="发表于 2023-01-31 10:06:13">2023-01-31</time></span></div><div class="content">十大经典排序算法C++实现（vector容器）前言​	排序算法是十分重要的算法，在各种设计中都会使用到，了解各种排序算法的机理和逻辑是很有必要的。本文采用C++语言来实现经典的十大排序算法，算法均实现从小到大排序，数据存储容器使用的是vector，vector容器可以实现数据的随机访问，即可以使用下标来访问容器中的任意数据。
（春节期间玩了几天，不然早就发出来了hhh）
基础函数准备​	本文预先定义了两个函数，一个用于对两个int型数据进行交换，另一个用于打印vector容器中的数据，下面给出其定义
1234567891011121314//用于交换两个int类型元素void mySwap(int&amp; a, int&amp; b)&#123;	int temp = a;	a = b;	b = temp;&#125;//打印vector&lt;int&gt;类型容器的内容void show(vector&lt;int&gt;&amp; v)&#123;	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); i ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/6c44e5f2.html" title="LeetCode695岛屿最大面积（广度优先搜索和深度优先搜索）"><img class="post_bg" src="/img/p5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode695岛屿最大面积（广度优先搜索和深度优先搜索）"></a></div><div class="recent-post-info"><a class="article-title" href="/post/6c44e5f2.html" title="LeetCode695岛屿最大面积（广度优先搜索和深度优先搜索）">LeetCode695岛屿最大面积（广度优先搜索和深度优先搜索）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-01-19T06:15:29.000Z" title="发表于 2023-01-19 14:15:29">2023-01-19</time></span></div><div class="content">题目描述给你一个大小为 m x n 的二进制矩阵 grid 。
岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
岛屿的面积是岛上值为 1 的单元格的数目。
计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。链接：https://leetcode.cn/problems/max-area-of-island
示例：

输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]输出：6解释：答案不应该是 11 ，因为岛屿只 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/eb314caa.html" title="C++中lambda表达式"><img class="post_bg" src="/img/p6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++中lambda表达式"></a></div><div class="recent-post-info"><a class="article-title" href="/post/eb314caa.html" title="C++中lambda表达式">C++中lambda表达式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-01-16T05:25:17.000Z" title="发表于 2023-01-16 13:25:17">2023-01-16</time></span></div><div class="content">Lambda表达式介绍在c++11标准以后，c++有三种方法来创建一个可以被调用的对象。

函数指针
仿函数
Lambda表达式

函数指针函数指针是c语言里面就存在的东西，从名字我们不难看出，函数指针实际上就是一个指针变量，指向一个函数，然后我们就可以利用这个指针来实现对函数的调用，以及作为形参，从而实现编程的灵活性和多样性。
在使用一个函数指针前，需要进行声明，假设我们有一个全局函数为：
int fun(int a,int b)&#123;&#125;
那么我们这个函数的函数指针类型就为：
int (*)(int,int);
其中第一个int表示函数的返回值类型，第一个小括号里面，*代表这是一个指针类型，第二个小括号里面表示函数的参数列表类型。如果我们想声明一个函数指针，那么我们可以直接在*后面添加变量名字。int (*p)(int,int);这就声明了一个函数指针p，声明完成以后就需要对变量进行赋值，直接采用p = fun或者p = &amp;fun两种写法是一致的。
下面给出基础的函数指针用法。
12345678910111213141516void f1(int a)&#12 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/45bd81aa.html" title="面向对象编程的员工管理系统"><img class="post_bg" src="/img/p4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象编程的员工管理系统"></a></div><div class="recent-post-info"><a class="article-title" href="/post/45bd81aa.html" title="面向对象编程的员工管理系统">面向对象编程的员工管理系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-01-08T06:12:40.000Z" title="发表于 2023-01-08 14:12:40">2023-01-08</time></span></div><div class="content">面向对象编程的员工管理系统问题描述设计一个职工管理系统，职工包括普通职工，经理和老板，这个系统能够实现对上诉职工信息进行增加，删除，修改，查询等功能，同时还需要将职工信息保存在文件中，保证系统关闭以后下次启动不会丢失信息。
前期知识准备面向对象的思想C++是一门面向对象的编程语言，面向对象思想和面向过程思想有着相差极大的思考模式，作为面向对象的思维来说，当你拿到一个问题时，你分析这个问题不再是第一步先做什么，第二步再做什么，这是面向过程的思维，你应该分析这个问题里面有哪些类和对象，这是第一点，然后再分析这些类和对象应该具有哪些属性和方法。
其中， 对象是用于计算机语言对问题域中事物的描述，对象通过“属性（attribute）”和“方法（method）”来分别对应事物所具有的静态属性和动态属性。类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性。类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
我们在分析现实问题时，会将问题进行抽象处理，抽象出一个一个的类，这些类具有各自的作用，但有个原则就是某个方法要在合适的类里面。当然各种类之间根据现实 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/post/7114887a.html" title="c++文件基本读写操作"><img class="post_bg" src="/img/p7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c++文件基本读写操作"></a></div><div class="recent-post-info"><a class="article-title" href="/post/7114887a.html" title="c++文件基本读写操作">c++文件基本读写操作</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-01-06T10:24:25.000Z" title="发表于 2023-01-06 18:24:25">2023-01-06</time></span></div><div class="content">C++文件基础操作文件介绍此处只讨论计算机文件，计算机文件是以计算机硬盘为载体存储在计算机上的信息集合。是文件的一种，下列出现的文件一词，均指计算机文件。
我们知道，计算机底层是由二极管和物理电路构成，因此市场上计算机大部分采用二进制存储模式来存储数据，这里的数据就包括文档，图片，音频，视频等。这些数据都以01串，也就是二进制的模式来存储。文件的名字通常是以文件名加上后缀（也叫文件扩展名），文件名用于区别同一类型下不同文件，后缀用于指示文件的类型。本文只考虑对文本文档文件的操作，即以.txt为后缀的文件，其他类型文件有各自独有的处理方法，不过基础原理都一致。有兴趣的可以自行查阅资料。
C++中的文件流C++ 标准库中专门提供了 3 个类用于实现文件操作，它们统称为文件流类，这 3 个类分别为：

ifstream：专用于从文件中读取数据；

ofstream：专用于向文件中写入数据；

fstream：既可用于从文件中读取数据，又可用于向文件中写入数据。


这三个文件流都位于fstream头文件中，使用之前需要将这个头文件包含进来。同时我们需要自己创建文件流对象来对不同文件进行操作。 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/post/1dfa3723.html" title="C++运算符重载"><img class="post_bg" src="/img/p2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++运算符重载"></a></div><div class="recent-post-info"><a class="article-title" href="/post/1dfa3723.html" title="C++运算符重载">C++运算符重载</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-12-25T07:48:02.000Z" title="发表于 2022-12-25 15:48:02">2022-12-25</time></span></div><div class="content">C++中各类型运算符重载函数重载的定义C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。这就是重载函数。重载函数常用来实现功能类似而所处理的数据类型不同的问题。只有函数返回值类型不同的重载函数是不正确的重载。
C++中运算符重载类型双目运算符重载（+，-，*，&#x2F;）双目运算符，即指需要两个运算数的运算符。
给出Person类，数据域包括一个人的姓名和年龄，同时设置其为私有属性，为了能访问到私有属性，我们写了对应的public方法来获取和修改他们的值，类结构如下：
123456789101112131415161718192021222324class Person&#123;    public:    void setname(string name)//修改名字    &#123;        m_Name = name;    &#125;    void setage(int age)//修改年龄    &#123;        m_Age = age;    &# ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/chai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">柴</div><div class="author-info__description">我们每个人都是一座孤岛</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>拍拍头</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了C++！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/8f1c791d.html" title="和彤宝的2023年度总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="和彤宝的2023年度总结"/></a><div class="content"><a class="title" href="/post/8f1c791d.html" title="和彤宝的2023年度总结">和彤宝的2023年度总结</a><time datetime="2024-02-06T03:32:59.000Z" title="发表于 2024-02-06 11:32:59">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣-剑指 Offer 30.包含min函数的栈(最小栈)"/></a><div class="content"><a class="title" href="/post/a17b1dd0.html" title="力扣-剑指 Offer 30.包含min函数的栈(最小栈)">力扣-剑指 Offer 30.包含min函数的栈(最小栈)</a><time datetime="2023-05-23T09:38:45.000Z" title="发表于 2023-05-23 17:38:45">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/99c27b28.html" title="C++智能指针"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针"/></a><div class="content"><a class="title" href="/post/99c27b28.html" title="C++智能指针">C++智能指针</a><time datetime="2023-03-29T08:01:21.000Z" title="发表于 2023-03-29 16:01:21">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9bbc6cc6.html" title="B+树的C/C++实现"><img src="/img/p8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+树的C/C++实现"/></a><div class="content"><a class="title" href="/post/9bbc6cc6.html" title="B+树的C/C++实现">B+树的C/C++实现</a><time datetime="2023-03-23T05:58:35.000Z" title="发表于 2023-03-23 13:58:35">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/827ca9cd.html" title="十大经典排序算法"><img src="/img/p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十大经典排序算法"/></a><div class="content"><a class="title" href="/post/827ca9cd.html" title="十大经典排序算法">十大经典排序算法</a><time datetime="2023-01-31T02:06:13.000Z" title="发表于 2023-01-31 10:06:13">2023-01-31</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/c/" style="font-size: 1.1em; color: #999">c++</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/12/"><span class="card-archive-list-date">十二月 2022</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">11</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-02-06T09:11:05.762Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 柴</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>